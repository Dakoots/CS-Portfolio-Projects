**What was the problem you were solving in the projects for this course?**
The projects focused on building a course advisor system that could efficiently load, store, sort, and retrieve course information for the Computer Science program. I needed to analyze different data structures to understand their performance trade-offs for tasks such as insertion, sorting, and searching.

**How did you approach the problem?**
I began by breaking down the requirements into two parts: a runtime analysis of different data structures (vector, hash table, and binary search tree) and a working implementation that sorts and displays course details. This approach allowed me to deeply evaluate the performance implications of each data structure, reinforcing the importance of choosing the right structure for a given problem. Understanding data structures is critical because they directly affect the efficiency, scalability, and responsiveness of an application.

**How did you overcome any roadblocks you encountered while going through the activities or project?**
Throughout the project, I encountered challenges such as handling inconsistent input formats and ensuring efficient error handling. I overcame these by implementing robust parsing functions and thorough validation checks for each course entry. When selecting data structures, I also referred to academic resources and coding best practices to understand and mitigate performance pitfalls, such as dealing with potential worst-case scenarios in hash tables.

**How has your work on this project expanded your approach to designing software and developing programs?**
This project broadened my perspective on software design by highlighting the importance of analyzing algorithmic efficiency and resource utilization early in the development process. It taught me to weigh the trade-offs between different implementations and to consider both theoretical and practical aspects of design, which is invaluable for creating scalable and efficient applications.

**How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**
Working on this project has led me to adopt a more modular and systematic coding style. I now emphasize clear documentation, consistent naming conventions, and thorough error handling, which together improve code maintainability and readability. By structuring my code into distinct functions and classes, I've made it easier to test, debug, and extend, ensuring that my programs remain adaptable as project requirements evolve.

